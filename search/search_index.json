{
    "docs": [
        {
            "location": "/",
            "text": "What is Lightbus?\n\u00b6\n\n\nLightbus allows your backend processes to communicate, run background tasks,\nand expose internal APIs.\n\n\nLightbus uses Redis as its underlying transport, although support\nfor other platforms may eventually be added.\n\n\nLightbus requires Python 3.6 or above.\n\n\nLightbus is under active development and is still pre-release.\n\nYou can \ntrack progress in GitHub\n.\n\n\nDesigned for ease of use\n\u00b6\n\n\nLightbus is designed with developers in mind. The syntax aims to\nbe intuitive and familiar, and common problems are caught with\nclear and helpful error messages.\n\n\nFor example, a naive authentication API:\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \nuser_registered\n \n=\n \nEvent\n(\nparameters\n=\n(\n'username'\n,\n \n'email'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nuser\n,\n \npassword\n):\n\n        \nreturn\n \n(\n\n            \nuser\n \n==\n \n'admin'\n\n            \nand\n \npassword\n \n==\n \n'secret'\n\n        \n)\n\n\n\n\n\nThis can be called as follows:\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\nbus\n.\nauth\n.\ncheck_password\n(\n\n    \nuser\n=\n'admin'\n,\n\n    \npassword\n=\n'secret'\n\n\n)\n\n\n# Returns true\n\n\n\n\n\nYou can also listen for events:\n\n\ndef\n \nsend_signup_email\n(\nevent_message\n,\n\n                      \nusername\n,\n \nemail\n):\n\n    \nsend_mail\n(\nemail\n,\n\n        \nsubject\n=\nf\n'Welcome \n{username}\n'\n\n    \n)\n\n\n\nbus\n.\nauth\n.\nuser_registered\n.\nlisten\n(\n\n    \nsend_signup_email\n\n\n)\n\n\n\n\n\nTo get started checkout the \ninstallation\n\nand \nquickstart\n guides.",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-lightbus",
            "text": "Lightbus allows your backend processes to communicate, run background tasks,\nand expose internal APIs.  Lightbus uses Redis as its underlying transport, although support\nfor other platforms may eventually be added.  Lightbus requires Python 3.6 or above.  Lightbus is under active development and is still pre-release. \nYou can  track progress in GitHub .",
            "title": "What is Lightbus?"
        },
        {
            "location": "/#designed-for-ease-of-use",
            "text": "Lightbus is designed with developers in mind. The syntax aims to\nbe intuitive and familiar, and common problems are caught with\nclear and helpful error messages.  For example, a naive authentication API:  class   AuthApi ( Api ): \n     user_registered   =   Event ( parameters = ( 'username' ,   'email' )) \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   user ,   password ): \n         return   ( \n             user   ==   'admin' \n             and   password   ==   'secret' \n         )   This can be called as follows:  import   lightbus  bus   =   lightbus . create ()  bus . auth . check_password ( \n     user = 'admin' , \n     password = 'secret'  )  # Returns true   You can also listen for events:  def   send_signup_email ( event_message , \n                       username ,   email ): \n     send_mail ( email , \n         subject = f 'Welcome  {username} ' \n     )  bus . auth . user_registered . listen ( \n     send_signup_email  )   To get started checkout the  installation \nand  quickstart  guides.",
            "title": "Designed for ease of use"
        },
        {
            "location": "/installation/",
            "text": "Preface: Installing Python 3.6 (or above)\n\u00b6\n\n\nLightbus requires Python 3.6 or newer as it relies upon Python's new \n\nasyncio\n and \ntype hinting\n features. This is readily available \nfor all major operating systems but you should make sure you have it \ninstalled as per the steps below before installing Lightbus.\n\n\nmacOS\n\u00b6\n\n\nYou can check your current version of Python as follows:\n\n\n$ python3 --version\nPython 3.6.4\n\n\n\n\n\nYou need version 3.6 or above to run Lightbus. You can install it\nby choosing one of the following:\n\n\n\n\nInstall Python 3.6 using Homebrew\n \u2013 This is the easiest option, you will\n   install that latest version of Python 3.\n\n\nInstall Python 3.6 using Homebrew + pyenv\n \u2013 This option has some additional\n   steps, but you will have complete control over the Python versions available to you.\n   If you work on multiple Python projects this may be more suitable.\n\n\nInstall Python 3.6 manually\n \u2013 Not recommended\n\n\n\n\nLinux\n\u00b6\n\n\nYour Linux distribution may already come with Python 3.6 installed. You can check your \nPython version as follows:\n\n\n$ python3 --version\nPython 3.6.4\n\n\n\n\n\nYou need version 3.6 or above to run Lightbus. Digital Ocean has a \n\nbeginner-suitable guide\n on installing Python 3 which you may find useful.\n\n\nIf you require more granular control of your python versions you may find \npyenv\n more suitable.\n\n\nWindows\n\u00b6\n\n\nLightbus is not currently tested for deployment on Windows, so your millage may vary. \nThe Hitchhiker's Guide to Python covers \ninstalling Python 3 on Windows\n.\n\n\nInstalling Lightbus\n\u00b6\n\n\nInstalling using pip (recommended)\n\u00b6\n\n\nAt time of writing we were yet to do an official release. Please install via git in the mean-time.\n\n\n$ pip3 install lightbus\n\n\n\n\n\nInstalling using git\n\u00b6\n\n\nThis will clone the bleeding-edge version Lightbus and install it ready to use. This is useful \nif you need the latest (albeit unstable) changes, or if you wish to modify the Lightbus source.\n\n\n$ cd my-project/\n\n$ mkdir vendor\n$ git clone https://github.com/adamcharnock/lightbus.git vendor/lightbus\n$ pip3 install -e vendor/lightbus\n\n\n\n\n\nInstalling Redis\n\u00b6\n\n\nLightbus relies on \nRedis\n as its primary transport. Specifically it relies on the new Redis 'streams' \nfeature to provide robust message handling. This will be available in Redis 5.0, due around mid-2018.\nUntil then you should build Redis from source as follows:\n\n\n$ git clone https://github.com/antirez/redis.git\n$ cd redis\n$ make\n$ ./src/redis-server\n\n\n\n\n\nCheck it works\n\u00b6\n\n\nYou should now have:\n\n\n\n\nPython 3.6 or above installed\n\n\nLightbus installed\n\n\nRedis installed and running\n\n\n\n\nYou check check everything is setup correctly by starting up lightbus:\n\n\n$ lightbus run\n\n\n\n\n\nLightbus should start without errors and wait for messages. \nYou can exit using \nCtrl\n+\nC\n.",
            "title": "Installation"
        },
        {
            "location": "/installation/#preface-installing-python-36-or-above",
            "text": "Lightbus requires Python 3.6 or newer as it relies upon Python's new  asyncio  and  type hinting  features. This is readily available \nfor all major operating systems but you should make sure you have it \ninstalled as per the steps below before installing Lightbus.",
            "title": "Preface: Installing Python 3.6 (or above)"
        },
        {
            "location": "/installation/#macos",
            "text": "You can check your current version of Python as follows:  $ python3 --version\nPython 3.6.4  You need version 3.6 or above to run Lightbus. You can install it\nby choosing one of the following:   Install Python 3.6 using Homebrew  \u2013 This is the easiest option, you will\n   install that latest version of Python 3.  Install Python 3.6 using Homebrew + pyenv  \u2013 This option has some additional\n   steps, but you will have complete control over the Python versions available to you.\n   If you work on multiple Python projects this may be more suitable.  Install Python 3.6 manually  \u2013 Not recommended",
            "title": "macOS"
        },
        {
            "location": "/installation/#linux",
            "text": "Your Linux distribution may already come with Python 3.6 installed. You can check your \nPython version as follows:  $ python3 --version\nPython 3.6.4  You need version 3.6 or above to run Lightbus. Digital Ocean has a  beginner-suitable guide  on installing Python 3 which you may find useful.  If you require more granular control of your python versions you may find  pyenv  more suitable.",
            "title": "Linux"
        },
        {
            "location": "/installation/#windows",
            "text": "Lightbus is not currently tested for deployment on Windows, so your millage may vary. \nThe Hitchhiker's Guide to Python covers  installing Python 3 on Windows .",
            "title": "Windows"
        },
        {
            "location": "/installation/#installing-lightbus",
            "text": "",
            "title": "Installing Lightbus"
        },
        {
            "location": "/installation/#installing-using-pip-recommended",
            "text": "At time of writing we were yet to do an official release. Please install via git in the mean-time.  $ pip3 install lightbus",
            "title": "Installing using pip (recommended)"
        },
        {
            "location": "/installation/#installing-using-git",
            "text": "This will clone the bleeding-edge version Lightbus and install it ready to use. This is useful \nif you need the latest (albeit unstable) changes, or if you wish to modify the Lightbus source.  $ cd my-project/\n\n$ mkdir vendor\n$ git clone https://github.com/adamcharnock/lightbus.git vendor/lightbus\n$ pip3 install -e vendor/lightbus",
            "title": "Installing using git"
        },
        {
            "location": "/installation/#installing-redis",
            "text": "Lightbus relies on  Redis  as its primary transport. Specifically it relies on the new Redis 'streams' \nfeature to provide robust message handling. This will be available in Redis 5.0, due around mid-2018.\nUntil then you should build Redis from source as follows:  $ git clone https://github.com/antirez/redis.git\n$ cd redis\n$ make\n$ ./src/redis-server",
            "title": "Installing Redis"
        },
        {
            "location": "/installation/#check-it-works",
            "text": "You should now have:   Python 3.6 or above installed  Lightbus installed  Redis installed and running   You check check everything is setup correctly by starting up lightbus:  $ lightbus run  Lightbus should start without errors and wait for messages. \nYou can exit using  Ctrl + C .",
            "title": "Check it works"
        },
        {
            "location": "/concepts/",
            "text": "Lightbus allows processes to communicate through a\ncentral medium, and has out-of-the-box support for Redis.\nThis can be done using any combination of RPCs or events.\n\n\nWe'll describe these concepts and their relationships in\nmore detail below.\n\n\nService\n\u00b6\n\n\nThroughout this documentation we use the term \nservice\n\nto refer to one or more processes handling a common task.\nThese processes operate as a tightly-coupled whole.\n\n\nFor example, your company may run a help desk\n(e.g \nsupport.company.com\n) , an online store (\nstore.company.com\n),\nand an internal image resizing service.\nThis documentation considers each of these to be a 'service'.\n\n\nThe support and store services would likely have both a web process and a\nLightbus process each. The image resizing service would likely have a Lightbus\nprocess only.\n\n\nAll processes in a service should generally share the same API class\ndefinitions.\n\n\nA simple lightbus deployment could look something like this:\n\n\n\n\nLightbus processes\n\u00b6\n\n\nA Lightbus process is started with the \nlightbus run\n command.\nA Lightbus process typically waits for any bus activity\nand responds accordingly.\n\n\nLightbus processes are therefore concerned with:\n\n\n\n\nListening for events\n\n\nResponding to remote procedure calls\n\n\n\n\nIn handling either of these, the Lightbus process may fire\nadditional events or call other RPCs.\n\n\nA service may have zero-or-more Lightbus processes. \nA service\nwill only need a Lightbus process if it wishes to listen\nfor events or provide any RPCs which can be called.\n\n\nNon-Lightbus processes\n\u00b6\n\n\nA web server would be a typical example of a non-Lightbus process\n(e.g. Flask or Django). These processes can still interact with the\nbus, but will typically do so briefly as part of their other duties.\n\n\nNon-Lightbus process are therefore concerned with:\n\n\n\n\nFiring events\n\n\nCalling RPCs\n\n\n\n\nBus\n\u00b6\n\n\nIn computing, a bus is a shared communication medium. A bus allows any\nsoftware/hardware connected to that medium to communicate, as long as\ncommon rules are obeyed. In this sense a bus is very similar to a conversation\nbetween a group of people.\n\n\nIn electronics the communication medium can be a simple\ncopper cable. In software the communication medium is itself defined\nby software.\n\n\nLightbus uses Redis as its communication medium\n, although support\nfor other mediums may be added in future.\n\n\n\n\nNote\n\n\nThe core of Lightbus mostly consists of a programming interface\nand presentational nicities.\nThe connection with the communication medium is provided by\ncustomisable transports (see below). Lightbus ships with transports for Redis,\nbut transports could be created for other mediums should you wish.\n\n\n\n\nAPI\n\u00b6\n\n\nWhen we refer to an \nAPI\n, we are referring to an \nApi\n class definition.\n\nAll functionlaity on the bus is defined using APIs.\n\n\nFor example, consider an API for support cases in the help desk service\nmentioned above:\n\n\nclass\n \nSupportCaseApi\n(\nApi\n):\n\n    \ncase_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n'id'\n,\n \n'sender'\n,\n \n'subject'\n,\n \n'body'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'support.case'\n\n\n    \ndef\n \nget\n(\nself\n,\n \nid\n):\n\n        \nreturn\n \nget_case_from_db\n(\npk\n=\nid\n)\n\n\n\n\n\nThis API defines an event, a procedure, and the name used to address the API\non the bus. The help desk service could define multiple additional APIs as needed.\n\n\nRemote Procedure Calls (RPCs)\n\u00b6\n\n\nA remote procedure call is where you call a procedure available on the bus. The authoritative\nservice executes the procedure and you receive the result. This is useful when:\n\n\n\n\nYou require information from a service\n\n\nYou wish to wait until a remote procedure has completed an action\n\n\n\n\nRPCs do not currently feature a 'fire and forget' mode of operation.\n\n\nYou can perform an RPC as follows:\n\n\nsupport_case\n \n=\n \nbus\n.\nsupport\n.\ncase\n.\nget\n(\npk\n=\n123\n)\n\n\n\n\n\nRPCs provide at-most-once semantics.\n\n\nEvents\n\u00b6\n\n\nFiring an event will place the event onto the bus and return immediately. No information\nis provided as to whether the event was processed, or indeed of it was received by any\nother service at all. No return value is provided when firing an event.\n\n\nThis is useful when:\n\n\n\n\nYou wish to allow non-authoritative services to receive information without needing to concern yourself\n   with their implementation\n\n\nYou wish the authoritative service to perform a known task in the background\n\n\n\n\nThe \nquickstart\n provides an example of the latter case.\n\n\nEvents provide at-least-once semantics.\n\n\nTransports\n\u00b6\n\n\nTransports provide the communications system for Lightbus. There are four types\nof transport:\n\n\n\n\nRPC transports\n \u2013 sends and consumes RPC calls\n\n\nResult transports\n \u2013 sends and receives RPC results\n\n\nEvent transports\n \u2013 sends and consumes events\n\n\nSchema transports\n \u2013 stores and retrieves the \nbus schema\n\n\n\n\nLightbus ships with a Redis-backed implementation of each of these transports.\n\n\nLightbus can be configured to use custom transports either globally, or on a per-API level.",
            "title": "Concepts"
        },
        {
            "location": "/concepts/#service",
            "text": "Throughout this documentation we use the term  service \nto refer to one or more processes handling a common task.\nThese processes operate as a tightly-coupled whole.  For example, your company may run a help desk\n(e.g  support.company.com ) , an online store ( store.company.com ),\nand an internal image resizing service.\nThis documentation considers each of these to be a 'service'.  The support and store services would likely have both a web process and a\nLightbus process each. The image resizing service would likely have a Lightbus\nprocess only.  All processes in a service should generally share the same API class\ndefinitions.  A simple lightbus deployment could look something like this:",
            "title": "Service"
        },
        {
            "location": "/concepts/#lightbus-processes",
            "text": "A Lightbus process is started with the  lightbus run  command.\nA Lightbus process typically waits for any bus activity\nand responds accordingly.  Lightbus processes are therefore concerned with:   Listening for events  Responding to remote procedure calls   In handling either of these, the Lightbus process may fire\nadditional events or call other RPCs.  A service may have zero-or-more Lightbus processes.  A service\nwill only need a Lightbus process if it wishes to listen\nfor events or provide any RPCs which can be called.",
            "title": "Lightbus processes"
        },
        {
            "location": "/concepts/#non-lightbus-processes",
            "text": "A web server would be a typical example of a non-Lightbus process\n(e.g. Flask or Django). These processes can still interact with the\nbus, but will typically do so briefly as part of their other duties.  Non-Lightbus process are therefore concerned with:   Firing events  Calling RPCs",
            "title": "Non-Lightbus processes"
        },
        {
            "location": "/concepts/#bus",
            "text": "In computing, a bus is a shared communication medium. A bus allows any\nsoftware/hardware connected to that medium to communicate, as long as\ncommon rules are obeyed. In this sense a bus is very similar to a conversation\nbetween a group of people.  In electronics the communication medium can be a simple\ncopper cable. In software the communication medium is itself defined\nby software.  Lightbus uses Redis as its communication medium , although support\nfor other mediums may be added in future.   Note  The core of Lightbus mostly consists of a programming interface\nand presentational nicities.\nThe connection with the communication medium is provided by\ncustomisable transports (see below). Lightbus ships with transports for Redis,\nbut transports could be created for other mediums should you wish.",
            "title": "Bus"
        },
        {
            "location": "/concepts/#api",
            "text": "When we refer to an  API , we are referring to an  Api  class definition. All functionlaity on the bus is defined using APIs.  For example, consider an API for support cases in the help desk service\nmentioned above:  class   SupportCaseApi ( Api ): \n     case_created   =   Event ( parameters = ( 'id' ,   'sender' ,   'subject' ,   'body' )) \n\n     class   Meta : \n         name   =   'support.case' \n\n     def   get ( self ,   id ): \n         return   get_case_from_db ( pk = id )   This API defines an event, a procedure, and the name used to address the API\non the bus. The help desk service could define multiple additional APIs as needed.",
            "title": "API"
        },
        {
            "location": "/concepts/#remote-procedure-calls-rpcs",
            "text": "A remote procedure call is where you call a procedure available on the bus. The authoritative\nservice executes the procedure and you receive the result. This is useful when:   You require information from a service  You wish to wait until a remote procedure has completed an action   RPCs do not currently feature a 'fire and forget' mode of operation.  You can perform an RPC as follows:  support_case   =   bus . support . case . get ( pk = 123 )   RPCs provide at-most-once semantics.",
            "title": "Remote Procedure Calls (RPCs)"
        },
        {
            "location": "/concepts/#events",
            "text": "Firing an event will place the event onto the bus and return immediately. No information\nis provided as to whether the event was processed, or indeed of it was received by any\nother service at all. No return value is provided when firing an event.  This is useful when:   You wish to allow non-authoritative services to receive information without needing to concern yourself\n   with their implementation  You wish the authoritative service to perform a known task in the background   The  quickstart  provides an example of the latter case.  Events provide at-least-once semantics.",
            "title": "Events"
        },
        {
            "location": "/concepts/#transports",
            "text": "Transports provide the communications system for Lightbus. There are four types\nof transport:   RPC transports  \u2013 sends and consumes RPC calls  Result transports  \u2013 sends and receives RPC results  Event transports  \u2013 sends and consumes events  Schema transports  \u2013 stores and retrieves the  bus schema   Lightbus ships with a Redis-backed implementation of each of these transports.  Lightbus can be configured to use custom transports either globally, or on a per-API level.",
            "title": "Transports"
        },
        {
            "location": "/quick-start/",
            "text": "Requirements\n\u00b6\n\n\nBefore continuing, ensure you have completed the following steps detailed in\nthe \ninstallation section\n:\n\n\n\n\nInstalled Python 3.6 or above\n\n\nInstalled Lightbus\n\n\nRunning a Redis server (built from the Redis unstable branch)\n\n\nRead the \nconcepts section\n\n\n\n\nAnatomy lesson\n\u00b6\n\n\nWhen using Lightbus you will still run your various services\nas normal. For web-based software this will likely include one or more\nprocesses to handle web traffic (e.g. Django, Flask).\nYou may or may not also have some other processes running for other purposes.\n\n\nIn addition to this, Lightbus will have its own process started via\n\nlightbus run\n.\n\n\nWhile the roles of these processes are not strictly defined, in most\ncircumstances their use should break down as follows:\n\n\n\n\nLightbus processes\n \u2013 Respond to remote procedure calls, listen for\n  and handle events.\n\n\nOther processes (web etc)\n \u2013 Perform remote procedure calls, fire events\n\n\n\n\nThe starting point for the lightbus process is a \nbus.py\n file. You\nshould create this in your project root. You can also configure\nwhere Lightbus looks for this module using the \n--bus\n option or\nby setting the \nLIGHTBUS_MODULE\n environment variable.\n\n\nDefine your API\n\u00b6\n\n\nFirst we will define the API the lightbus will serve.\nCreate the following in a \nbus.py\n file:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n,\n \npassword\n):\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n\n\n\nYou should now be able to startup Lightbus as follows:\n\n\nlightbus run\n\n\n\n\nLightbus will output some logging data which will include a list of\nAPIs in its registry, including your new \nauth\n API:\n\n\n\n\nLeave Lightbus running and open a new terminal window for the next stage.\n\n\nRemote procedure calls\n\u00b6\n\n\nWith Lightbus running, open a new terminal window and create a file named\n\ncall_procedure.py\n in the same directory as your \nbus.py\n. The\n\ncall_procedure.py\n file name is arbitrary, it simply allows us to\nexperiment with accessing the bus.\n\n\n# call_procedure.py\n\n\nimport\n \nlightbus\n\n\n\n# Create a bus object\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Call the check_password() procedure on our auth API\n\n\nvalid\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\n\n    \nusername\n=\n'admin'\n,\n\n    \npassword\n=\n'secret'\n\n\n)\n\n\n\n# Show the result\n\n\nif\n \nvalid\n:\n\n    \nprint\n(\n'Password valid!'\n)\n\n\nelse\n:\n\n    \nprint\n(\n'Oops, bad username or password'\n)\n\n\n\n\n\nEvents\n\u00b6\n\n\nEvents allow services to broadcast a message to any other services that\ncare to listen. Events are fired by the service which 'owns' the API and\nreceived by any Lightbus service, which can include the owning service itself\n(as we do below).\n\n\nThe owning service can be more accurately referred to as the\n\nauthoritative service\n. The authoritative service is the service\nwhich contains the class definition within its codebase. Lightbus only\nallows the authoritative service to fire events for an API. Any service can\nlisten for any event.\n\n\nWe will talk more about this in \nconcepts\n. For now let's look\nat some code. Below we modify our \nAuthApi\n in \nbus.py\n to add a \nuser_registered\n\nevent. We also use the \nbefore_server_start()\n hook to setup a listener for\nthat event:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \nuser_registered\n \n=\n \nEvent\n(\nparameters\n=\n(\n'username'\n,\n \n'email'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n,\n \npassword\n):\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n\n\ndef\n \nbefore_server_start\n(\nbus\n):\n\n    \n# before_server_start() is called on lightbus startup,\n\n    \n# this allows you to setup your listeners.\n\n\n    \n# Call send_welcome_email() when we receive the user_registered event\n\n    \nbus\n.\nauth\n.\nuser_registered\n.\nlisten\n(\nsend_welcome_email\n)\n\n\n\n\ndef\n \nsend_welcome_email\n(\nevent_message\n,\n \nusername\n,\n \nemail\n):\n\n    \n# In our example we'll just print something to the console,\n\n    \n# rather than send an actual email\n\n    \nprint\n(\nf\n'Subject: Welcome to our site, \n{username}\n'\n)\n\n    \nprint\n(\nf\n'To: \n{email}\n'\n)\n\n\n\n\n\nNow create \nfire_event.py\n, this will fire the event on the bus.\nAs with the previous example, this file name is arbitrary.\nIn a real-world scenario this code may live in your web application's\nuser registration success handler.\n\n\n# fire_event.py\n\n\nimport\n \nlightbus\n\n\n\n# Import the AuthApi to make it available to Lightbus\n\n\nfrom\n \n.bus\n \nimport\n \nAuthApi\n\n\n\n# Create a bus object\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Fire the event. There is no return value when firing events\n\n\nbus\n.\nauth\n.\nuser_registered\n.\nfire\n(\n\n    \nusername\n=\n'admin'\n,\n\n    \nemail\n=\n'admin@example.com'\n\n\n)\n\n\n\n\n\nThere a two important differences here:\n\n\n\n\nWe call \nbus.auth.user_registered.fire()\n to fire the \nuser_registered\n event on\n   the \nauth\n API. This will place the event onto the bus to be consumed any\n   listening services.\n\n\nWe import the \nAuthApi\n class. This registers it with Lightbus, thereby indicating\n   we are the authoritative service for this API and can therefore fire events upon it.\n\n\n\n\nFurther reading\n\u00b6\n\n\nThis quickstart has covered the basics of Lightbus, and has hopefully given you a\ngood starting point. Reading through the remainder of this documentation should give you\na wider awareness of the features available and underlying concepts.",
            "title": "Quick start"
        },
        {
            "location": "/quick-start/#requirements",
            "text": "Before continuing, ensure you have completed the following steps detailed in\nthe  installation section :   Installed Python 3.6 or above  Installed Lightbus  Running a Redis server (built from the Redis unstable branch)  Read the  concepts section",
            "title": "Requirements"
        },
        {
            "location": "/quick-start/#anatomy-lesson",
            "text": "When using Lightbus you will still run your various services\nas normal. For web-based software this will likely include one or more\nprocesses to handle web traffic (e.g. Django, Flask).\nYou may or may not also have some other processes running for other purposes.  In addition to this, Lightbus will have its own process started via lightbus run .  While the roles of these processes are not strictly defined, in most\ncircumstances their use should break down as follows:   Lightbus processes  \u2013 Respond to remote procedure calls, listen for\n  and handle events.  Other processes (web etc)  \u2013 Perform remote procedure calls, fire events   The starting point for the lightbus process is a  bus.py  file. You\nshould create this in your project root. You can also configure\nwhere Lightbus looks for this module using the  --bus  option or\nby setting the  LIGHTBUS_MODULE  environment variable.",
            "title": "Anatomy lesson"
        },
        {
            "location": "/quick-start/#define-your-api",
            "text": "First we will define the API the lightbus will serve.\nCreate the following in a  bus.py  file:  # bus.py  from   lightbus   import   Api  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   username ,   password ): \n         return   username   ==   'admin'   and   password   ==   'secret'   You should now be able to startup Lightbus as follows:  lightbus run  Lightbus will output some logging data which will include a list of\nAPIs in its registry, including your new  auth  API:   Leave Lightbus running and open a new terminal window for the next stage.",
            "title": "Define your API"
        },
        {
            "location": "/quick-start/#remote-procedure-calls",
            "text": "With Lightbus running, open a new terminal window and create a file named call_procedure.py  in the same directory as your  bus.py . The call_procedure.py  file name is arbitrary, it simply allows us to\nexperiment with accessing the bus.  # call_procedure.py  import   lightbus  # Create a bus object  bus   =   lightbus . create ()  # Call the check_password() procedure on our auth API  valid   =   bus . auth . check_password ( \n     username = 'admin' , \n     password = 'secret'  )  # Show the result  if   valid : \n     print ( 'Password valid!' )  else : \n     print ( 'Oops, bad username or password' )",
            "title": "Remote procedure calls"
        },
        {
            "location": "/quick-start/#events",
            "text": "Events allow services to broadcast a message to any other services that\ncare to listen. Events are fired by the service which 'owns' the API and\nreceived by any Lightbus service, which can include the owning service itself\n(as we do below).  The owning service can be more accurately referred to as the authoritative service . The authoritative service is the service\nwhich contains the class definition within its codebase. Lightbus only\nallows the authoritative service to fire events for an API. Any service can\nlisten for any event.  We will talk more about this in  concepts . For now let's look\nat some code. Below we modify our  AuthApi  in  bus.py  to add a  user_registered \nevent. We also use the  before_server_start()  hook to setup a listener for\nthat event:  # bus.py  from   lightbus   import   Api ,   Event  class   AuthApi ( Api ): \n     user_registered   =   Event ( parameters = ( 'username' ,   'email' )) \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   username ,   password ): \n         return   username   ==   'admin'   and   password   ==   'secret'  def   before_server_start ( bus ): \n     # before_server_start() is called on lightbus startup, \n     # this allows you to setup your listeners. \n\n     # Call send_welcome_email() when we receive the user_registered event \n     bus . auth . user_registered . listen ( send_welcome_email )  def   send_welcome_email ( event_message ,   username ,   email ): \n     # In our example we'll just print something to the console, \n     # rather than send an actual email \n     print ( f 'Subject: Welcome to our site,  {username} ' ) \n     print ( f 'To:  {email} ' )   Now create  fire_event.py , this will fire the event on the bus.\nAs with the previous example, this file name is arbitrary.\nIn a real-world scenario this code may live in your web application's\nuser registration success handler.  # fire_event.py  import   lightbus  # Import the AuthApi to make it available to Lightbus  from   .bus   import   AuthApi  # Create a bus object  bus   =   lightbus . create ()  # Fire the event. There is no return value when firing events  bus . auth . user_registered . fire ( \n     username = 'admin' , \n     email = 'admin@example.com'  )   There a two important differences here:   We call  bus.auth.user_registered.fire()  to fire the  user_registered  event on\n   the  auth  API. This will place the event onto the bus to be consumed any\n   listening services.  We import the  AuthApi  class. This registers it with Lightbus, thereby indicating\n   we are the authoritative service for this API and can therefore fire events upon it.",
            "title": "Events"
        },
        {
            "location": "/quick-start/#further-reading",
            "text": "This quickstart has covered the basics of Lightbus, and has hopefully given you a\ngood starting point. Reading through the remainder of this documentation should give you\na wider awareness of the features available and underlying concepts.",
            "title": "Further reading"
        },
        {
            "location": "/worked-example/",
            "text": "In the following worked example we will create three services:\n\n\n\n\nAn image resizing service\n\n\nAn online store\n\n\nA stats dashboard\n\n\n\n\nThis will involve a combination of web interfaces (using \nFlask\n), and Lightbus APIs.\nThe goal is to show how Lightbus can allow multiple services to interact.\n\n\nGetting started\n\u00b6\n\n\nThe code created here can be found in Lightbus example \nex03_worked_example\n, although\nthe code will be repeated below. There is a directory for each service we will\ncreate \u2013 \nstore/\n, \ndashboard/\n, and \nimage/\n.\n\n\nBefore continuing ensure you have installed \nflask\n and \nhoncho\n:\n\n\npip3 install flask honcho\n\n\n\n\n\nA passing familiarity with \nFlask\n may be useful, but is not required. [Honcho]\nwill assist us in running the various processes required for our services.\n\n\nWe will assume you\nhave already read and completed the \ninstallation\n,\n\nquick start\n, and \nconcepts\n sections.\n\n\nImage resizing service\n\u00b6\n\n\nThe image resizing service will be a simple Lightbus API, the purpose of which\nis to allow our store to resize images prior to display:\n\n\n# image/bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n\n\n\nclass\n \nImageApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'image'\n\n\n    \ndef\n \nresize\n(\nself\n,\n \nurl\n,\n \nwidth\n,\n \nheight\n):\n\n        \n# This is a demo, so just return an animal picture of the correct size\n\n        \nreturn\n \nf\n'https://placeimg.com/\n{width}\n/\n{height}\n/animals?_=\n{url}\n'\n\n\n\n\n\nThere is no web interface for this service, so this is all we need.\n\n\nStore service\n\u00b6\n\n\nOur store will have both a Lightbus API and a web interface. We'll start\nwith the API first:\n\n\n# store/bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n,\n \nconfigure_logging\n\n\nconfigure_logging\n()\n\n\n\nclass\n \nStoreApi\n(\nApi\n):\n\n    \npage_view\n \n=\n \nEvent\n(\nparameters\n=\n(\n'url'\n,\n \n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'store'\n\n\n\n\n\nThis API has a single event called \npage_view\n. The store web interface will fire this\nevent whenever a page is viewed.\n\n\nOur store web interface uses Flask and is a little longer:\n\n\nimport\n \nlightbus\n\n\nfrom\n \nflask\n \nimport\n \nFlask\n\n\n\n# Ensure the Store API is loaded so we can fire events on it\n\n\nfrom\n \n.bus\n \nimport\n \nStoreApi\n\n\n\n# Setup flask\n\n\napp\n \n=\n \nFlask\n(\n__name__\n)\n\n\n\n# Create our bus\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# A dummy list of pets our store will sell\n\n\nPETS\n \n=\n \n(\n\n    \n'http://store.company.com/image1.jpg'\n,\n\n    \n'http://store.company.com/image2.jpg'\n,\n\n    \n'http://store.company.com/image3.jpg'\n,\n\n\n)\n\n\n\n@app\n.\nroute\n(\n'/'\n)\n\n\ndef\n \nhome\n():\n\n    \n# A view to list all available pets\n\n    \nhtml\n \n=\n \n'<h1>Online pet store</h1><br>'\n\n\n    \nfor\n \npet_num\n,\n \nimage_url\n \nin\n \nenumerate\n(\nPETS\n):\n\n        \n# Get an image of the appropriate size\n\n        \nresized_url\n \n=\n \nbus\n.\nimage\n.\nresize\n(\nurl\n=\nimage_url\n,\n \nwidth\n=\n200\n,\n \nheight\n=\n200\n)\n\n        \nhtml\n \n+=\n \n(\n\n            \nf\n'<a href=\"/pet/\n{pet_num}\n\">'\n\n            \nf\n'<img src=\"\n{resized_url}\n\">'\n\n            \nf\n'</a> '\n\n        \n)\n\n\n    \n# Fire the page view\n\n    \nbus\n.\nstore\n.\npage_view\n.\nfire\n(\nurl\n=\n'/'\n)\n\n\n    \nreturn\n \nhtml\n\n\n\n@app\n.\nroute\n(\n'/pet/<int:pet_num>'\n)\n\n\ndef\n \npet\n(\npet_num\n):\n\n    \n# Show an individual pet\n\n    \nresized_url\n \n=\n \nbus\n.\nimage\n.\nresize\n(\nurl\n=\nPETS\n[\npet_num\n],\n \nwidth\n=\n200\n,\n \nheight\n=\n200\n)\n\n\n    \n# Fire the page view\n\n    \nbus\n.\nstore\n.\npage_view\n.\nfire\n(\nurl\n=\nf\n'/pet/\n{pet_num}\n'\n)\n\n\n    \nhtml\n \n=\n \nf\n'<h1>Pet \n{pet_num}\n</h1>'\n\n    \nhtml\n \n=\n \nf\n'<img src=\"\n{resized_url}\n\"><br />'\n\n    \nreturn\n \nhtml\n\n\n\n\n\nInterlude: give it a go\n\u00b6\n\n\nWe're not quite done yet, but you can now startup the necessary processes and\nsee the store. You will need to run each of these in a separate terminal window:\n\n\n$ ls\nimage/       store/\n\n\n# Start our image resizing service\n\n$ lightbus run --bus\n=\nimage.bus\n\n\n# Start our store's web interface\n\n$ \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\n\n\n\n\nNow open \n127.0.0.1:5001\n in your browser and\nyou should see three animal pictures awaiting you. The URL for each\nimage was fetched from the image resizing service.\n\n\nThe flask web interface should also have some logging output akin to the following:\n\n\n\n\nHere you can see:\n\n\n\n\nimage.resize\n was called three times, once for each image\n\n\nThe \nstore.page_view\n event was fired\n\n\n\n\nNext we will create the dashboard which will make use of the \nstore.page_view\n event.\n\n\nDashboard service\n\u00b6\n\n\nThe dashboard service will provide internal reporting in the form\nof page view statistics for the online store.\n\n\nThere dashboard will need to both receive events and provide a web\ninterface. It will therefore need both a lightbus process and a\nweb process (we will later look at how to combine these).\n\n\nFist we will start with the \nbus.py\n file:\n\n\n# dashboard/bus.py\n\n\nimport\n \njson\n\n\n\npage_views\n \n=\n \n{}\n\n\n\ndef\n \nhandle_page_view\n(\nevent_message\n,\n \nurl\n):\n\n    \npage_views\n.\nsetdefault\n(\nurl\n,\n \n0\n)\n\n    \npage_views\n[\nurl\n]\n \n+=\n \n1\n\n    \nwith\n \nopen\n(\n'/tmp/.dashboard.db.json'\n,\n \n'w'\n)\n \nas\n \nf\n:\n\n        \njson\n.\ndump\n(\npage_views\n,\n \nf\n)\n\n\n\ndef\n \nbefore_server_start\n(\nbus\n):\n\n    \n# Called when lightbus starts up\n\n    \nbus\n.\nstore\n.\npage_view\n.\nlisten\n(\nhandle_page_view\n)\n\n\n\n\n\nThis is a simple listener for the \nbus.store.page_view\n event. This is event is fired by the\nstore's web interface we created above.\n\n\nNote we do not define any APIs,\ninstead we setup our event listener using the \nbefore_server_start()\n hook. Listening for this\nevent is all the dashboard's Lightbus process will do, it will not provide any APIs.\n\n\nThe \nhandle_page_view()\n handler persists each view to the Dashboard services' local database.\nIn a real service this would likely be a DBMS of some form (Postgres, MySQL,\nRedis, Mongo etc). For simplicity we just store JSON to a file.\n\n\nNow we'll define our dashboard's web interface:\n\n\n# dashboard/web.py\n\n\nimport\n \njson\n\n\nfrom\n \nflask\n \nimport\n \nFlask\n\n\n\napp\n \n=\n \nFlask\n(\n__name__\n)\n\n\n\n@app\n.\nroute\n(\n'/'\n)\n\n\ndef\n \nhome\n():\n\n    \nhtml\n \n=\n \n'<h1>Dashboard</h1>\n\\n\n'\n\n    \nhtml\n \n=\n \n'<p>Total store views</p>\n\\n\n'\n\n\n    \nwith\n \nopen\n(\n'/tmp/.dashboard.db.json'\n,\n \n'r'\n)\n \nas\n \nf\n:\n\n        \npage_views\n \n=\n \njson\n.\nload\n(\nf\n)\n\n\n    \nhtml\n \n+=\n \n'<ul>'\n\n    \nfor\n \nurl\n,\n \ntotal_views\n \nin\n \npage_views\n.\nitems\n():\n\n        \nhtml\n \n+=\n \nf\n'<li>URL <code>\n{url}\n</code>: \n{total_views}\n</li>'\n\n    \nhtml\n \n+=\n \n'</ul>'\n\n\n    \nreturn\n \nhtml\n\n\n\n\n\nThis reads the JSON data that was written by the event listener in \ndashboard/bus.py\n above,\nthen render it to HTML.\n\n\nRun it!\n\u00b6\n\n\nYou should now have the following python files:\n\n\nimage/bus.py\nstore/bus.py\nstore/web.py\ndashboard/bus.py\ndashboard/web.py\n\n\n\n\n\nThis translates into the following processes:\n\n\n\n\n\n\n\n\nService\n\n\nProcess type\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nImage reszier\n\n\nLightbus\n\n\nWill resize images and return a new URL\n\n\n\n\n\n\nStore\n\n\nWeb\n\n\nRender the store UI. Use bus to resize image and fire events\n\n\n\n\n\n\nStore\n\n\nBus\n\n\nWhile the store does have a \nbus.py\n, it does not have any RPCs to serve. We therefore do not need to run a lightbus service.\n\n\n\n\n\n\nDashboard\n\n\nWeb\n\n\nRender the dashboard web UI, read data from database\n\n\n\n\n\n\nDashboard\n\n\nLightbus\n\n\nListen for page view events and store stats to database\n\n\n\n\n\n\n\n\nYou can run each of these as follows:\n\n\n$ ls\ndashboard/    image/    store/\n\n\n# Image resizer\n\n$ lightbus run --bus\n=\nimage.bus\n\n\n# Store\n\n$ \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\n\n\n# Dashboard\n\n$ lightbus run --bus\n=\ndashboard.bus\n$ \nFLASK_APP\n=\ndashboard/web.py flask run --port\n=\n5000\n\n\n\n\n\nHowever,\n you may find it easier to startup these processes\nwill the \nhoncho\n tool we installed earlier. First, create\na file called \nProcfile\n:\n\n\n# Procfile\n\nimage_resizer_bus: lightbus run --bus\n=\nimage.bus\nstore_web:         \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\ndashboard_bus:     lightbus run --bus\n=\ndashboard.bus\ndashboard_web:     \nFLASK_APP\n=\ndashboard/web.py flask run --port\n=\n5000\n\n\n\n\n\nAnd now use \nhoncho\n to startup all the processes together:\n\n\n$ ls\nProcfile    dashboard/    image/    store/\n\n$ honcho start\n\n\n\n\nIf you see an error stating \ncommand not found\n, ensure you installed \nhoncho\n as\ndetailed above (\npip3 install honcho\n).\n\n\nOnce started, checkout the output for any errors. Each log line will state the process\nit came from. If all is well, you should see something like this:\n\n\n\n\nYou should now be able to access the store's web interface at \n127.0.0.1:5001\n as you\ndid previously.\n\n\nUpon viewing the page, the web interface will resize each image and fire the \nstore.page_view\n\nevent. The dashboard will receive the \nstore.page_view\n event and create the\ndatabase for the first time. The logging output should reflect this:\n\n\n\n\nAt this point you can view the dashboard at \n127.0.0.1:5000\n. Note that opening the dashboard\nbefore this point would have resulted in an error as the database would not have been\ncreated.\n\n\nThe dashboard should show a simple list of URLs plus the total number of page views for each.\nGo back to the store and view a few pages. Now refresh the dashboard and note the new data.\n\n\nWrapping up\n\u00b6\n\n\nWhile the services we have have created here are very crude, hopefully they have helped\nshow how Lightbus can be used as a effective communications infrastructure.\n\n\nNext we will the detail the ins-and-outs of each area of Lightbus \u2013 APIs, RPCs, events, configuration,\nschemas, and so on.\n\n\nExtra: Combining dashboard processes\n\u00b6\n\n\nAs an extra bonus, below we show how to combine both dashboard processes into one.\nThis is a bit more advanced and requires some knowledge of Python's asyncio features.\n\nYou can use Lightbus perfectly well without adding this complexity.\n\n\nBehind the scenes Lightbus is powered by Python's asyncio library. Therefore,\nif we also use an asyncio-based web server we can combine the Lightbus and web\nprocesses. In this case we'll use \naiohttp\n as our web server, rather than\nFlask which we used earlier.\n\n\n# dashboard/combined.py\n\n\nimport\n \nlightbus\n\n\nfrom\n \naiohttp\n \nimport\n \nweb\n\n\n\n# Note we no longer need to store page view data on disk.\n\n\n# We simply hold it in memory using a dictionary.\n\n\npage_views\n \n=\n \n{}\n\n\n\n\ndef\n \nhome_view\n(\nrequest\n):\n\n    \n\"\"\"Render the simple dashboard UI\"\"\"\n\n    \nhtml\n \n=\n \n'<h1>Dashboard</h1>\n\\n\n'\n\n    \nhtml\n \n+=\n \n'<p>Total store views</p>\n\\n\n'\n\n\n    \nhtml\n \n+=\n \n'<ul>'\n\n    \n# Read the page views from our `page_views` global variable\n\n    \nfor\n \nurl\n,\n \ntotal_views\n \nin\n \npage_views\n.\nitems\n():\n\n        \nhtml\n \n+=\n \nf\n'<li>URL <code>\n{url}\n</code>: \n{total_views}\n views</li>'\n\n    \nhtml\n \n+=\n \n'</ul>'\n\n\n    \nreturn\n \nweb\n.\nResponse\n(\nbody\n=\nhtml\n,\n \ncontent_type\n=\n'text/html'\n)\n\n\n\n\ndef\n \nhandle_page_view\n(\nevent_message\n,\n \nurl\n):\n\n    \n\"\"\"Handle an incoming page view\"\"\"\n\n    \npage_views\n.\nsetdefault\n(\nurl\n,\n \n0\n)\n\n    \n# Store the incoming view in our `page_views` global variable\n\n    \npage_views\n[\nurl\n]\n \n+=\n \n1\n\n\n\n\nasync\n \ndef\n \nstart_listener\n(\napp\n):\n\n    \n# Create the asyncio task which will listen for the page_view event\n\n    \nlistener_task\n \n=\n \nawait\n \napp\n.\nbus\n.\nstore\n.\npage_view\n.\nlisten_async\n(\nhandle_page_view\n)\n\n\n    \n# Store the task against `app` in case we need it later (hint: we don't)\n\n    \napp\n[\n'page_view_listener'\n]\n \n=\n \nlistener_task\n\n\n\n\nasync\n \ndef\n \ncleanup\n(\napp\n):\n\n    \n# We're using aiohttp to manage the event loop, so\n\n    \n# we need to close up the lightbus client manually on shutdown.\n\n    \n# This will cancel any listeners and close down the redis connections.\n\n    \n# If don't do this you'll see errors on shutdown.\n\n    \nawait\n \napp\n.\nbus\n.\nbus_client\n.\nclose_async\n()\n\n\n\n\ndef\n \nmain\n():\n\n    \n# Make sure Lightbus formats its logs correctly\n\n    \nlightbus\n.\nconfigure_logging\n()\n\n\n    \n# Create our lightbus client and our web application\n\n    \nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n    \napp\n \n=\n \nweb\n.\nApplication\n()\n\n\n    \napp\n.\nrouter\n.\nadd_route\n(\n'GET'\n,\n \n'/'\n,\n \nhome_view\n)\n\n    \napp\n.\non_startup\n.\nappend\n(\nstart_listener\n)\n\n    \napp\n.\non_cleanup\n.\nappend\n(\ncleanup\n)\n\n\n    \n# Store the bus on `app` as we'll need it\n\n    \n# in start_listener() and cleanup()\n\n    \napp\n.\nbus\n \n=\n \nbus\n\n\n    \nweb\n.\nrun_app\n(\napp\n,\n \nhost\n=\n'127.0.0.1'\n,\n \nport\n=\n5000\n)\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nmain\n()\n\n\n\n\n\nNew create a new Procfile called \nProcfile_combined\n. This will use your new combined\ndashboard process along with the existing image resizer and store services:\n\n\n# Procfile_combined\n\n\nimage_resizer_bus: lightbus run --bus\n=\nimage.bus\nstore_web: \nFLASK_DEBUG\n=\n1\n \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\n\ndashboard_combined: python dashboard/combined.py\n\n\n\n\nNote that the \ndashboard_web\n and \ndashboard_lightbus\n have gone and \ndashboard_combined\n\nhas been added.\n\n\nYou can now start up your new collection of services using:\n\n\n$ ls\nProcfile    Procfile_combined    dashboard/    image/    store/\n\n$ honcho start -f Procfile_combined",
            "title": "Worked example"
        },
        {
            "location": "/worked-example/#getting-started",
            "text": "The code created here can be found in Lightbus example  ex03_worked_example , although\nthe code will be repeated below. There is a directory for each service we will\ncreate \u2013  store/ ,  dashboard/ , and  image/ .  Before continuing ensure you have installed  flask  and  honcho :  pip3 install flask honcho  A passing familiarity with  Flask  may be useful, but is not required. [Honcho]\nwill assist us in running the various processes required for our services.  We will assume you\nhave already read and completed the  installation , quick start , and  concepts  sections.",
            "title": "Getting started"
        },
        {
            "location": "/worked-example/#image-resizing-service",
            "text": "The image resizing service will be a simple Lightbus API, the purpose of which\nis to allow our store to resize images prior to display:  # image/bus.py  from   lightbus   import   Api ,   Event  class   ImageApi ( Api ): \n\n     class   Meta : \n         name   =   'image' \n\n     def   resize ( self ,   url ,   width ,   height ): \n         # This is a demo, so just return an animal picture of the correct size \n         return   f 'https://placeimg.com/ {width} / {height} /animals?_= {url} '   There is no web interface for this service, so this is all we need.",
            "title": "Image resizing service"
        },
        {
            "location": "/worked-example/#store-service",
            "text": "Our store will have both a Lightbus API and a web interface. We'll start\nwith the API first:  # store/bus.py  from   lightbus   import   Api ,   Event ,   configure_logging  configure_logging ()  class   StoreApi ( Api ): \n     page_view   =   Event ( parameters = ( 'url' ,   )) \n\n     class   Meta : \n         name   =   'store'   This API has a single event called  page_view . The store web interface will fire this\nevent whenever a page is viewed.  Our store web interface uses Flask and is a little longer:  import   lightbus  from   flask   import   Flask  # Ensure the Store API is loaded so we can fire events on it  from   .bus   import   StoreApi  # Setup flask  app   =   Flask ( __name__ )  # Create our bus  bus   =   lightbus . create ()  # A dummy list of pets our store will sell  PETS   =   ( \n     'http://store.company.com/image1.jpg' , \n     'http://store.company.com/image2.jpg' , \n     'http://store.company.com/image3.jpg' ,  )  @app . route ( '/' )  def   home (): \n     # A view to list all available pets \n     html   =   '<h1>Online pet store</h1><br>' \n\n     for   pet_num ,   image_url   in   enumerate ( PETS ): \n         # Get an image of the appropriate size \n         resized_url   =   bus . image . resize ( url = image_url ,   width = 200 ,   height = 200 ) \n         html   +=   ( \n             f '<a href=\"/pet/ {pet_num} \">' \n             f '<img src=\" {resized_url} \">' \n             f '</a> ' \n         ) \n\n     # Fire the page view \n     bus . store . page_view . fire ( url = '/' ) \n\n     return   html  @app . route ( '/pet/<int:pet_num>' )  def   pet ( pet_num ): \n     # Show an individual pet \n     resized_url   =   bus . image . resize ( url = PETS [ pet_num ],   width = 200 ,   height = 200 ) \n\n     # Fire the page view \n     bus . store . page_view . fire ( url = f '/pet/ {pet_num} ' ) \n\n     html   =   f '<h1>Pet  {pet_num} </h1>' \n     html   =   f '<img src=\" {resized_url} \"><br />' \n     return   html",
            "title": "Store service"
        },
        {
            "location": "/worked-example/#interlude-give-it-a-go",
            "text": "We're not quite done yet, but you can now startup the necessary processes and\nsee the store. You will need to run each of these in a separate terminal window:  $ ls\nimage/       store/ # Start our image resizing service \n$ lightbus run --bus = image.bus # Start our store's web interface \n$  FLASK_APP = store/web.py flask run --port = 5001   Now open  127.0.0.1:5001  in your browser and\nyou should see three animal pictures awaiting you. The URL for each\nimage was fetched from the image resizing service.  The flask web interface should also have some logging output akin to the following:   Here you can see:   image.resize  was called three times, once for each image  The  store.page_view  event was fired   Next we will create the dashboard which will make use of the  store.page_view  event.",
            "title": "Interlude: give it a go"
        },
        {
            "location": "/worked-example/#dashboard-service",
            "text": "The dashboard service will provide internal reporting in the form\nof page view statistics for the online store.  There dashboard will need to both receive events and provide a web\ninterface. It will therefore need both a lightbus process and a\nweb process (we will later look at how to combine these).  Fist we will start with the  bus.py  file:  # dashboard/bus.py  import   json  page_views   =   {}  def   handle_page_view ( event_message ,   url ): \n     page_views . setdefault ( url ,   0 ) \n     page_views [ url ]   +=   1 \n     with   open ( '/tmp/.dashboard.db.json' ,   'w' )   as   f : \n         json . dump ( page_views ,   f )  def   before_server_start ( bus ): \n     # Called when lightbus starts up \n     bus . store . page_view . listen ( handle_page_view )   This is a simple listener for the  bus.store.page_view  event. This is event is fired by the\nstore's web interface we created above.  Note we do not define any APIs,\ninstead we setup our event listener using the  before_server_start()  hook. Listening for this\nevent is all the dashboard's Lightbus process will do, it will not provide any APIs.  The  handle_page_view()  handler persists each view to the Dashboard services' local database.\nIn a real service this would likely be a DBMS of some form (Postgres, MySQL,\nRedis, Mongo etc). For simplicity we just store JSON to a file.  Now we'll define our dashboard's web interface:  # dashboard/web.py  import   json  from   flask   import   Flask  app   =   Flask ( __name__ )  @app . route ( '/' )  def   home (): \n     html   =   '<h1>Dashboard</h1> \\n ' \n     html   =   '<p>Total store views</p> \\n ' \n\n     with   open ( '/tmp/.dashboard.db.json' ,   'r' )   as   f : \n         page_views   =   json . load ( f ) \n\n     html   +=   '<ul>' \n     for   url ,   total_views   in   page_views . items (): \n         html   +=   f '<li>URL <code> {url} </code>:  {total_views} </li>' \n     html   +=   '</ul>' \n\n     return   html   This reads the JSON data that was written by the event listener in  dashboard/bus.py  above,\nthen render it to HTML.",
            "title": "Dashboard service"
        },
        {
            "location": "/worked-example/#run-it",
            "text": "You should now have the following python files:  image/bus.py\nstore/bus.py\nstore/web.py\ndashboard/bus.py\ndashboard/web.py  This translates into the following processes:     Service  Process type  Purpose      Image reszier  Lightbus  Will resize images and return a new URL    Store  Web  Render the store UI. Use bus to resize image and fire events    Store  Bus  While the store does have a  bus.py , it does not have any RPCs to serve. We therefore do not need to run a lightbus service.    Dashboard  Web  Render the dashboard web UI, read data from database    Dashboard  Lightbus  Listen for page view events and store stats to database     You can run each of these as follows:  $ ls\ndashboard/    image/    store/ # Image resizer \n$ lightbus run --bus = image.bus # Store \n$  FLASK_APP = store/web.py flask run --port = 5001  # Dashboard \n$ lightbus run --bus = dashboard.bus\n$  FLASK_APP = dashboard/web.py flask run --port = 5000   However,  you may find it easier to startup these processes\nwill the  honcho  tool we installed earlier. First, create\na file called  Procfile :  # Procfile \nimage_resizer_bus: lightbus run --bus = image.bus\nstore_web:          FLASK_APP = store/web.py flask run --port = 5001 \ndashboard_bus:     lightbus run --bus = dashboard.bus\ndashboard_web:      FLASK_APP = dashboard/web.py flask run --port = 5000   And now use  honcho  to startup all the processes together:  $ ls\nProcfile    dashboard/    image/    store/\n\n$ honcho start  If you see an error stating  command not found , ensure you installed  honcho  as\ndetailed above ( pip3 install honcho ).  Once started, checkout the output for any errors. Each log line will state the process\nit came from. If all is well, you should see something like this:   You should now be able to access the store's web interface at  127.0.0.1:5001  as you\ndid previously.  Upon viewing the page, the web interface will resize each image and fire the  store.page_view \nevent. The dashboard will receive the  store.page_view  event and create the\ndatabase for the first time. The logging output should reflect this:   At this point you can view the dashboard at  127.0.0.1:5000 . Note that opening the dashboard\nbefore this point would have resulted in an error as the database would not have been\ncreated.  The dashboard should show a simple list of URLs plus the total number of page views for each.\nGo back to the store and view a few pages. Now refresh the dashboard and note the new data.",
            "title": "Run it!"
        },
        {
            "location": "/worked-example/#wrapping-up",
            "text": "While the services we have have created here are very crude, hopefully they have helped\nshow how Lightbus can be used as a effective communications infrastructure.  Next we will the detail the ins-and-outs of each area of Lightbus \u2013 APIs, RPCs, events, configuration,\nschemas, and so on.",
            "title": "Wrapping up"
        },
        {
            "location": "/worked-example/#extra-combining-dashboard-processes",
            "text": "As an extra bonus, below we show how to combine both dashboard processes into one.\nThis is a bit more advanced and requires some knowledge of Python's asyncio features. You can use Lightbus perfectly well without adding this complexity.  Behind the scenes Lightbus is powered by Python's asyncio library. Therefore,\nif we also use an asyncio-based web server we can combine the Lightbus and web\nprocesses. In this case we'll use  aiohttp  as our web server, rather than\nFlask which we used earlier.  # dashboard/combined.py  import   lightbus  from   aiohttp   import   web  # Note we no longer need to store page view data on disk.  # We simply hold it in memory using a dictionary.  page_views   =   {}  def   home_view ( request ): \n     \"\"\"Render the simple dashboard UI\"\"\" \n     html   =   '<h1>Dashboard</h1> \\n ' \n     html   +=   '<p>Total store views</p> \\n ' \n\n     html   +=   '<ul>' \n     # Read the page views from our `page_views` global variable \n     for   url ,   total_views   in   page_views . items (): \n         html   +=   f '<li>URL <code> {url} </code>:  {total_views}  views</li>' \n     html   +=   '</ul>' \n\n     return   web . Response ( body = html ,   content_type = 'text/html' )  def   handle_page_view ( event_message ,   url ): \n     \"\"\"Handle an incoming page view\"\"\" \n     page_views . setdefault ( url ,   0 ) \n     # Store the incoming view in our `page_views` global variable \n     page_views [ url ]   +=   1  async   def   start_listener ( app ): \n     # Create the asyncio task which will listen for the page_view event \n     listener_task   =   await   app . bus . store . page_view . listen_async ( handle_page_view ) \n\n     # Store the task against `app` in case we need it later (hint: we don't) \n     app [ 'page_view_listener' ]   =   listener_task  async   def   cleanup ( app ): \n     # We're using aiohttp to manage the event loop, so \n     # we need to close up the lightbus client manually on shutdown. \n     # This will cancel any listeners and close down the redis connections. \n     # If don't do this you'll see errors on shutdown. \n     await   app . bus . bus_client . close_async ()  def   main (): \n     # Make sure Lightbus formats its logs correctly \n     lightbus . configure_logging () \n\n     # Create our lightbus client and our web application \n     bus   =   lightbus . create () \n     app   =   web . Application () \n\n     app . router . add_route ( 'GET' ,   '/' ,   home_view ) \n     app . on_startup . append ( start_listener ) \n     app . on_cleanup . append ( cleanup ) \n\n     # Store the bus on `app` as we'll need it \n     # in start_listener() and cleanup() \n     app . bus   =   bus \n\n     web . run_app ( app ,   host = '127.0.0.1' ,   port = 5000 )  if   __name__   ==   '__main__' : \n     main ()   New create a new Procfile called  Procfile_combined . This will use your new combined\ndashboard process along with the existing image resizer and store services:  # Procfile_combined \n\nimage_resizer_bus: lightbus run --bus = image.bus\nstore_web:  FLASK_DEBUG = 1   FLASK_APP = store/web.py flask run --port = 5001  dashboard_combined: python dashboard/combined.py  Note that the  dashboard_web  and  dashboard_lightbus  have gone and  dashboard_combined \nhas been added.  You can now start up your new collection of services using:  $ ls\nProcfile    Procfile_combined    dashboard/    image/    store/\n\n$ honcho start -f Procfile_combined",
            "title": "Extra: Combining dashboard processes"
        },
        {
            "location": "/typing/",
            "text": "Inbound: \ndecode -> deserialise -> cast\n\nOutbound: \ndeform -> serialize -> encode\n\n\n\n\nTypes not transmitted with data\n\n\nValidation:\n\n\nData validated against the schema\n\n\nAPI schemas are shared on the bus\n\n\n\n\n\n\nOutbound:\n\n\nData is encoded as JSON by default\n\n\nTherefore all values are transmitted as JSON-safe types\n\n\nDeform:\n Lightbus handles NamedTuples, dataclasses by converting\n  them into dictionaries. Other common types such as\n  datetimes, Decimals etc are converted into strings.\n  Internally this is referred to as the \ndeform\n process.\n\n\nSerialize:\n Structures the data in a way suitable for the\n  transport.\n\n\nEncode:\n Converts the data to a form suitable for transmission.\n  This typically means stringifying it, for which lightbus\n  uses JSON encoding by default.\n\n\n\n\n\n\nInbound (the reverse of the outbound process)\n\n\nDecode:\n JSON decode (by default) the incoming data\n\n\nDeserialise:\n Convert the data from its bus-level structure\n\n\nCast:\n Best effort casting of parameters/results based on the\n  type hinting provided in the calling code.\n\n\n\n\n\n\n\n\nCusom objects can be transmitted on the bus as long as they define the\n\n__to_bus__()\n magic method. Conversely, custom objects can be recieved\nby providing a type hint for class, where the class defines the\n\n__from_bus__()\n method.",
            "title": "Typing"
        },
        {
            "location": "/apis/",
            "text": "Note\n\n\nWe recommend read the \nconcepts\n section before continuing\nas this will give you a useful overview before delving into the details \nbelow.\n\n\n\n\nAPIs specify the functionality available on the bus. To do this you \ndefine API classes within (or import API classes into) your \nbus.py\n file.\n\n\nFor example:\n\n\nclass\n \nSupportCaseApi\n(\nApi\n):\n\n    \n# An event\n\n    \ncase_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n'id'\n,\n \n'sender'\n,\n \n'subject'\n,\n \n'body'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \n# API name on the bus\n\n        \nname\n \n=\n \n'support.case'\n\n\n    \n# A procedure\n\n    \ndef\n \nget\n(\nself\n,\n \nid\n):\n\n        \nreturn\n \nget_case_from_db\n(\npk\n=\nid\n)\n\n\n\n\n\nA service can define zero or more APIs, and each API can contain \nzero or more events and zero or more procedures.\n\n\nThe \nMeta\n specifies options regarding the API, with \nname\n being \nthe only required option. The name specifies how the API will be \naccessed on the bus.\n\n\nYou could use the above API as follows:\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Call the get_case() RPC.\n\n\ncase\n \n=\n \nbus\n.\nsupport\n.\ncase\n.\nget_case\n(\nid\n=\n123\n)\n\n\n\n# Fire the case_created event\n\n\nbus\n.\nsupport\n.\ncase\n.\ncase_created\n.\nfire\n(\n\n    \nid\n=\n123\n,\n\n    \nsender\n=\n'Joe'\n,\n\n    \nsubject\n=\n'I need support please!'\n,\n\n    \nbody\n=\n'...'\n,\n\n\n)\n\n\n\n\n\nOptions\n\u00b6\n\n\nname (str)\n\u00b6\n\n\nSpecifies the name of the API. This will determine how the API is addressed \non the bus. See \nnaming\n, below.\n\n\nname\n is a required option.\n\n\nauto_register (bool) = True\n\u00b6\n\n\nShould this API be registered with Lightbus upon import? This defaults to \nTrue\n, \nbut if you specifically wish to prevent the API from being automatically \nregistered with Lightbus you should set this to \nFalse\n.\n\n\nNaming\n\u00b6\n\n\nAs you can see above, API names can contain periods to allow you \nto structure your bus in a suitable form for your situation. \nSome example API naming schemes may look like:\n\n\nFormat: \n \n<\nservice\n>\n\n\nExample: \nsupport\n.\nget_case\n()\n\n         \nsupport\n.\nget_activity\n()\n\n\n\n\nFormat: \n \n<\nservice\n>\n.\n<\nobject\n>\n\n\nExample: \nsupport\n.\ncase\n.\nget\n()\n\n         \nsupport\n.\nactivity\n.\nget\n()\n\n\n\n\nFormat: \n \n<\ndeparment\n>\n.\n<\nservice\n>\n.\n<\nobject\n>\n\n\nExample: \nmarketing\n.\nwebsite\n.\nstats\n.\nget\n()\n\n         \nops\n.\nmonitoring\n.\nservers\n.\nget_status\n()\n\n\n\n\n\nAuthoritative and non-authoritative\n\u00b6\n\n\nThe service which defines an API is \nauthoritative\n for that API, and as \nsuch can perform some actions that are not allowed by services accessing the API.\n\n\nA service which is authoritative for an API:\n\n\n\n\nMust import the API class definition\n\n\nShould respond to remote procedure calls for the API\n   (i.e. by running a \nlightbus run\n process)\n\n\nMay fire events for the API\n\n\n\n\nConversely, a non-authoritative service may \nnot\n perform the above actions. \nFor example, the online store service could not fire the \nbus.support.case.case_created\n\nevent, nor should it import the \nSupportCaseApi\n class.\n\n\nOrganising many APIs\n\u00b6\n\n\n\n\nWill lightbus recognise a bus package as well as a bus module? \n  (i.e.\nbus/__init__.py\n?)",
            "title": "APIs"
        },
        {
            "location": "/apis/#options",
            "text": "",
            "title": "Options"
        },
        {
            "location": "/apis/#name-str",
            "text": "Specifies the name of the API. This will determine how the API is addressed \non the bus. See  naming , below.  name  is a required option.",
            "title": "name (str)"
        },
        {
            "location": "/apis/#auto_register-bool-true",
            "text": "Should this API be registered with Lightbus upon import? This defaults to  True , \nbut if you specifically wish to prevent the API from being automatically \nregistered with Lightbus you should set this to  False .",
            "title": "auto_register (bool) = True"
        },
        {
            "location": "/apis/#naming",
            "text": "As you can see above, API names can contain periods to allow you \nto structure your bus in a suitable form for your situation. \nSome example API naming schemes may look like:  Format:    < service >  Example:  support . get_case () \n          support . get_activity ()  Format:    < service > . < object >  Example:  support . case . get () \n          support . activity . get ()  Format:    < deparment > . < service > . < object >  Example:  marketing . website . stats . get () \n          ops . monitoring . servers . get_status ()",
            "title": "Naming"
        },
        {
            "location": "/apis/#authoritative-and-non-authoritative",
            "text": "The service which defines an API is  authoritative  for that API, and as \nsuch can perform some actions that are not allowed by services accessing the API.  A service which is authoritative for an API:   Must import the API class definition  Should respond to remote procedure calls for the API\n   (i.e. by running a  lightbus run  process)  May fire events for the API   Conversely, a non-authoritative service may  not  perform the above actions. \nFor example, the online store service could not fire the  bus.support.case.case_created \nevent, nor should it import the  SupportCaseApi  class.",
            "title": "Authoritative and non-authoritative"
        },
        {
            "location": "/apis/#organising-many-apis",
            "text": "Will lightbus recognise a bus package as well as a bus module? \n  (i.e. bus/__init__.py ?)",
            "title": "Organising many APIs"
        },
        {
            "location": "/rpcs/",
            "text": "Note\n\n\nWe recommend read the \nconcepts\n section before continuing\nas this will give you a useful overview before delving into the details \nbelow.\n\n\n\n\nRemote procedures calls (RPCs) are defined as methods on your API \nclasses. They are useful when either:\n\n\n\n\nYou require information from a service\n\n\nYou wish to wait until a remote procedure has completed an action\n\n\n\n\nDefinition\n\u00b6\n\n\nAs covered in previous sections, you define RPCs as follows:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n,\n \npassword\n):\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n    \ndef\n \nreset_password\n(\nself\n,\n \nusername\n):\n\n        \nreset_users_password_somehow\n(\nusername\n)\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n):\n\n        \nreturn\n \nget_user\n(\nusername\n)\n\n\n    \ndef\n \npromote_to_admin\n(\nusername\n):\n\n        \nuser\n \n=\n \nget_user\n(\nusername\n)\n\n        \nuser\n.\nadmin\n \n=\n \nTrue\n\n        \nuser\n.\nsave\n()\n\n\n\n\n\nBest practices\n\u00b6\n\n\nRPC implementation\n\u00b6\n\n\nIt is best to keep your RPCs simple and easy to understand. \nUse the API definition as a presentational system that wraps up \nthe business logic elsewhere within service.\n\n\nIf you find business logic creeping into your RPC definitions, \nconsider factoring it out and invoking it from the RPC definition.\n\n\nFor smaller services this will be less important, but as functionality \nis shared and used elsewhere within your service you may find it keeps \nyou code more managable.\n\n\nThis also leaves your RPCs definitions free do any API-specific \nlegwork such as data marshalling. For example, converting incoming natural keys \n(e.g. usernames) into the primary keys (i.e. user IDs) that your \nservice's may use internally.\n\n\nTimeouts\n\u00b6\n\n\nTODO. Handle timeouts gracefully.\n\n\nParameter values\n\u00b6\n\n\nWhen deciding the values your RPC should receive, consider:\n\n\n\n\nCan this value become out of date? For example, an entire user object \n  could become out of date, whereas a username or user ID would not. \n\n\nPacking and unpacking large data structures is computationally expensive.\n\n\nWill the values meaning change over time? For example, the meaning of 'today' or \n  'now' will change, but the meaning of a specific date & time will remain the same.\n\n\n\n\nType hints\n\u00b6\n\n\nAssuming you have validation enabled, specifying type hints on your \nRPCs will allow a number of errors to be caught automatically. For example:\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n:\n \nstr\n)\n \n->\n \nUser\n:\n\n        \nreturn\n \nget_user\n(\nusername\n)\n\n\n\n\n\nThis will validate that:\n\n\n\n\nThe incoming \nusername\n value is a string\n\n\nThe outgoing user object matches the annotations on the \nUser\n class\n\n\n\n\nLimitations\n\u00b6\n\n\nRPCs can only be called with keyword arguments. For example:\n\n\n# Raises an InvalidParameters exception\n\n\nresult\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\n'admin'\n,\n \n'secret'\n)\n\n\n\n# Success\n\n\nresult\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\nusername\n=\n'admin'\n,\n \npassword\n=\n'secret'\n)",
            "title": "Remote prcedure calls"
        },
        {
            "location": "/rpcs/#definition",
            "text": "As covered in previous sections, you define RPCs as follows:  # bus.py  from   lightbus   import   Api  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   username ,   password ): \n         return   username   ==   'admin'   and   password   ==   'secret' \n\n     def   reset_password ( self ,   username ): \n         reset_users_password_somehow ( username ) \n\n     def   get_user ( self ,   username ): \n         return   get_user ( username ) \n\n     def   promote_to_admin ( username ): \n         user   =   get_user ( username ) \n         user . admin   =   True \n         user . save ()",
            "title": "Definition"
        },
        {
            "location": "/rpcs/#best-practices",
            "text": "",
            "title": "Best practices"
        },
        {
            "location": "/rpcs/#rpc-implementation",
            "text": "It is best to keep your RPCs simple and easy to understand. \nUse the API definition as a presentational system that wraps up \nthe business logic elsewhere within service.  If you find business logic creeping into your RPC definitions, \nconsider factoring it out and invoking it from the RPC definition.  For smaller services this will be less important, but as functionality \nis shared and used elsewhere within your service you may find it keeps \nyou code more managable.  This also leaves your RPCs definitions free do any API-specific \nlegwork such as data marshalling. For example, converting incoming natural keys \n(e.g. usernames) into the primary keys (i.e. user IDs) that your \nservice's may use internally.",
            "title": "RPC implementation"
        },
        {
            "location": "/rpcs/#timeouts",
            "text": "TODO. Handle timeouts gracefully.",
            "title": "Timeouts"
        },
        {
            "location": "/rpcs/#parameter-values",
            "text": "When deciding the values your RPC should receive, consider:   Can this value become out of date? For example, an entire user object \n  could become out of date, whereas a username or user ID would not.   Packing and unpacking large data structures is computationally expensive.  Will the values meaning change over time? For example, the meaning of 'today' or \n  'now' will change, but the meaning of a specific date & time will remain the same.",
            "title": "Parameter values"
        },
        {
            "location": "/rpcs/#type-hints",
            "text": "Assuming you have validation enabled, specifying type hints on your \nRPCs will allow a number of errors to be caught automatically. For example:       def   get_user ( self ,   username :   str )   ->   User : \n         return   get_user ( username )   This will validate that:   The incoming  username  value is a string  The outgoing user object matches the annotations on the  User  class",
            "title": "Type hints"
        },
        {
            "location": "/rpcs/#limitations",
            "text": "RPCs can only be called with keyword arguments. For example:  # Raises an InvalidParameters exception  result   =   bus . auth . check_password ( 'admin' ,   'secret' )  # Success  result   =   bus . auth . check_password ( username = 'admin' ,   password = 'secret' )",
            "title": "Limitations"
        },
        {
            "location": "/events/",
            "text": "Note\n\n\nWe recommend read the \nconcepts\n section before continuing\nas this will give you a useful overview before delving into the details \nbelow.",
            "title": "Events"
        },
        {
            "location": "/configuration/",
            "text": "TBA\n\n\n\n\nConfiguring transports\n\n\nSimple\n\n\nPer-api",
            "title": "Configuration"
        },
        {
            "location": "/schema/",
            "text": "Lightbus processes automatically generate and share schemas for their available APIs.\nThese schemes can be used to validate the following:\n\n\n\n\nRemote procedure call parameters\n\n\nRemote procedure call return values\n\n\nEvent parameters\n\n\n\n\nThese schemas are shared using the configured \nSchemaTransprt\n (Redis, by default).\nEach Lightbus process will monitor for any schema changes.\n\n\nSpecifying types\n\u00b6\n\n\nLightbus will create a schema by inspecting the parameters\nand \ntype hints\n of your APIs' events and procedures.\n\n\nYou can use the schema functionality without type hints, but the level of validation\nprovided will be limited to ensuring parameter names match what is expected.\n\n\nTake the following API as an example:\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n,\n \nParameter\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \n# Here we specify event parameters in the long-form using Parameter().\n\n    \n# This provides sufficient information for the schema to be generated\n\n    \nuser_registered\n \n=\n \nEvent\n(\nparameters\n=\n(\n\n        \nParameter\n(\n'username'\n,\n \nstr\n),\n\n        \nParameter\n(\n'email'\n,\n \nstr\n),\n\n        \nParameter\n(\n'is_admin'\n,\n \nbool\n,\n \ndefault\n=\nFalse\n),\n\n    \n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \n# We annotate check_password() with the apropriate types\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n:\n \nstr\n,\n \npassword\n:\n \nstr\n)\n \n->\n \nbool\n:\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n\n\n\nCreate this in a \nbus.py\n and run:\n\n\n$ lightbus dumpschema\n\n\n\n\nThis will dump out the auto-generated schema for the above API. See\n\nschema format\n (below) for example output.\n\n\nSupported data types\n\u00b6\n\n\nLightbus maps Python types to JSON types. While Python-specific values can be sent using Lightbus,\nthese values will arrive in their JSON form. For example, if you send a \nstring\n then a \nstring\n will arrive.\nHowever, if you send the \nDecimal\n value \n3.124\n, then you will receive the \nstring\n value \n3.124\n instead.\n\n\nThe following types are reasonably interoperable:\n\n\n\n\n\n\n\n\nPython type sent\n\n\nJSON schema interpretation\n\n\nType received\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nstring\n\n\nstr\n\n\n\n\n\n\nint\n, \nfloat\n\n\nnumber\n\n\nint\n, \nfloat\n\n\n\n\n\n\nbool\n\n\nboolean\n\n\nbool\n\n\n\n\n\n\nlist\n, \ntuple\n\n\narray\n\n\nlist\n\n\n\n\n\n\nNone\n\n\nnull\n\n\nNone\n\n\n\n\n\n\ndict\n, \nMapping\n, etc\n\n\nobject\n\n\ndict\n\n\n\n\n\n\nMapping[str, ...]\n\n\nobject\n, with \npattern properties\n set\n\n\ndict\n\n\n\n\n\n\nTuple[A, B, C]\n\n\narray\n with \nmaxItems/minItems\n and \nitems\n set.\n\n\nlist\n\n\n\n\n\n\n\n\nThe following types will be successfully encoded and sent, but will arrive as their encoded equivalent:\n\n\n\n\n\n\n\n\nPython type\n\n\nJSON Schema type\n\n\nValue arrives as\n\n\n\n\n\n\n\n\n\n\nbytes\n, \nDecimal\n, \ncomplex\n\n\nstring\n\n\nstr\n\n\n\n\n\n\ndatetime\n, \ndate\n\n\nstr\n\n\nstr\n (ISO 8601)\n\n\n\n\n\n\nNamedTuple\n with annotations\n\n\nobject\n with \nspecific typed properties\n\n\ndict\n\n\n\n\n\n\nobject\n with annotations\n\n\nobject\n with \nspecific typed properties\n\n\ndict\n\n\n\n\n\n\n\n\nLightbus can also handle the following:\n\n\n\n\n\n\n\n\nPython type\n\n\nJSON Schema type\n\n\n\n\n\n\n\n\n\n\nAny\n\n\n{}\n (any value)\n\n\n\n\n\n\nUnion[...]\n\n\noneOf{...}\n (see \noneOf\n)\n\n\n\n\n\n\nEnum\n\n\nSets \nenum\n property\n\n\n\n\n\n\n\n\nAutomatic validation\n\u00b6\n\n\nBy default this validation will be validated in both the\nincoming and outgoing directions. Outgoing refers to\nthe dispatching of events or procedure calls to the bus.\nIncoming refers to the processing of procedure calls or\nhandling of received events.\n\n\nYou can configuring this using the \nvalidate\n\n\nconfiguration\n option.\n\n\nValidation configuration\n\u00b6\n\n\nYou can configure the validation behaviour in your\nbus' \nconfig.yaml\n.\n\n\nvalidate (bool) = true\n\u00b6\n\n\nYou can enable/disable validation using a boolean true/false flag:\n\n\n# In config.yaml\n\n\napis:\n\n    \ndefault:\n\n        \nvalidate: \nfalse\n\n\n\n\n\nFor finer grained control you can specify individual flags for incoming/outgoing\nvalidation:\n\n\n# In config.yaml\n\n\napis:\n\n    \ndefault:\n\n        \nvalidate:\n\n          \noutgoing: \ntrue\n\n          \nincoming: \nfalse\n\n\n\n\n\nstrict_validation (bool) = false\n\u00b6\n\n\nIf \nstrict_validation\n is \ntrue\n then calling a procedure for which no schema exists will\nresult in an error:\n\n\n# In config.yaml\n\n\napis:\n\n    \ndefault:\n\n        \nstrict_validation: \ntrue\n\n\n\n\n\nManual validation\n\u00b6\n\n\nTODO\n\n\nComplex types\n\u00b6\n\n\nThe Lightbus can derive a schema from both named tuples and classes.\n\n\nNamed Tuples\n\u00b6\n\n\nTake the following \nUser\n named tuple:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\nfrom\n \ntyping\n \nimport\n \nNamedTuple\n\n\n\n\nclass\n \nUser\n(\nNamedTuple\n):\n\n    \nusername\n:\n \nstr\n\n    \nname\n:\n \nstr\n\n    \nemail\n:\n \nstr\n\n    \nis_admin\n:\n \nbool\n \n=\n \nFalse\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n:\n \nstr\n)\n \n->\n \nUser\n:\n\n        \nreturn\n \n...\n\n\n\n\n\nRunning \nlightbus dumpschema\n will produce the following:\n\n\n{\n\n  \n\"auth\"\n:\n \n{\n\n    \n\"events\"\n:\n \n{},\n\n    \n\"rpcs\"\n:\n \n{\n\n      \n\"get_user\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n\n          \n//\n \nA\n \nsingle\n \nrequired\n \nusername\n \nstring\n \nparameter\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"RPC auth.get_user() parameters\"\n,\n\n          \n\"type\"\n:\n \n\"object\"\n\n          \n\"additionalProperties\"\n:\n \nfalse\n,\n\n          \n\"properties\"\n:\n \n{\n\n            \n\"username\"\n:\n \n{\n\"type\"\n:\n \n\"string\"\n}\n\n          \n},\n\n          \n\"required\"\n:\n \n[\n\n            \n\"username\"\n\n          \n],\n\n        \n},\n\n\n        \n//\n \nA\n \ncomplex\n \nobject\n \nis\n \nreturned\n\n        \n\"response\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"RPC auth.get_user() response\"\n,\n\n          \n\"type\"\n:\n \n\"object\"\n,\n\n          \n\"properties\"\n:\n \n{\n\n            \n\"username\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"name\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"email\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"is_admin\"\n:\n \n{\n\n              \n\"default\"\n:\n \nfalse\n,\n\n              \n\"type\"\n:\n \n\"boolean\"\n\n            \n}\n\n          \n},\n\n          \n\"required\"\n:\n \n[\n\"username\"\n,\n \n\"name\"\n,\n \n\"email\"\n],\n\n          \n\"additionalProperties\"\n:\n \nfalse\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\nDataclasses\n\u00b6\n\n\nDataclasses\n\nwere introduced in Python 3.7, with a\n\nbackport available\n for\nPython 3.6.\n\n\nLightbus supports dataclasses in the same way as it supports\n\nnamed tuples\n. For example:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\nfrom\n \ndataclasses\n \nimport\n \ndataclass\n\n\n\n@dataclass\n()\n\n\nclass\n \nUser\n(\nobject\n):\n\n    \nusername\n:\n \nstr\n\n    \nname\n:\n \nstr\n\n    \nemail\n:\n \nstr\n\n    \nis_admin\n:\n \nbool\n \n=\n \nFalse\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n:\n \nstr\n)\n \n->\n \nUser\n:\n\n        \nreturn\n \n...\n\n\n\n\n\nClasses\n\u00b6\n\n\nThe same can be achieved using regular classes. However, there are some notable points:\n\n\n\n\nAttributes prefixed with an underscore will be ignored\n\n\nIf used as a type hint for a parameter, then the class .... wait, will a json object get deserialised into a python object?\n   NO, this only happens in the config. I think you'll just get a dict for a parameter value\nTODO\n\n\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\n\n\nclass\n \nUser\n(\nobject\n)\n:\n\n    \nusername: \nstr\n\n    \nname: \nstr\n\n    \nemail: \nstr\n\n    \nis_admin: bool = \nFalse\n\n    \n# private attributes are ignored\n\n    \n_internal_value: str = \n''\n\n\n    \ndef\n \ndo_something\n(\nself\n)\n:\n\n        \npass\n\n\n\nclass\n \nAuthApi\n(\nApi\n)\n:\n\n\n    \nclass\n \nMeta:\n\n        \nname = \n'auth'\n\n\n    \ndef\n \nget_user\n(self, username: str) ->\n \nUser:\n\n        \nreturn\n \n...\n\n\n\n\n\nSchema format\n\u00b6\n\n\nYou won't need to worry about the schema format in your day-to-day use\nof Lightbus. However, an understanding of the format will be very\nuseful if you decide to build additional tooling.\n\n\nThe Lightbus schema format is simply a collection of child JSON Schemas.\nBelow is the schema for the example \nauth\n API shown above:\n\n\n//\n \nAuto-generated\n \nschema\n \nfor\n \nauth\n \nAPI\n\n\n{\n\n  \n\"auth\"\n:\n \n{\n\n\n    \n//\n \nEvents\n \nspecify\n \nonly\n \nparameters\n\n    \n\"events\"\n:\n \n{\n\n      \n\"user_registered\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"Event auth.user_registered parameters\"\n,\n\n          \n\"type\"\n:\n \n\"object\"\n,\n\n            \n\"username\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n          \n\"properties\"\n:\n \n{\n\n            \n\"email\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"is_admin\"\n:\n \n{\n\n              \n\"default\"\n:\n \nfalse\n,\n\n              \n\"type\"\n:\n \n\"boolean\"\n\n            \n}\n\n          \n},\n\n          \n\"required\"\n:\n \n[\n\n            \n\"username\"\n,\n\n            \n\"email\"\n\n          \n],\n\n          \n\"additionalProperties\"\n:\n \nfalse\n\n        \n}\n\n      \n}\n\n    \n},\n\n\n    \n//\n \nRPCs\n \nspecify\n \nboth\n \nparameters\n \nand\n \nresponse\n\n    \n\"rpcs\"\n:\n \n{\n\n      \n\"check_password\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"RPC auth.check_password() parameters\"\n,\n\n          \n\"type\"\n:\n \n\"object\"\n,\n\n          \n\"properties\"\n:\n \n{\n\n            \n\"username\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"password\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n}\n\n          \n},\n\n          \n\"required\"\n:\n \n[\n\n            \n\"username\"\n,\n\n            \n\"password\"\n\n          \n],\n\n          \n\"additionalProperties\"\n:\n \nfalse\n\n        \n},\n\n\n        \n\"response\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"RPC auth.check_password() response\"\n,\n\n          \n\"type\"\n:\n \n\"boolean\"\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\nThe generalised format is as follows:\n\n\n//\n \nGeneralised\n \nLightbus\n \nschema\n \nformat\n\n\n{\n\n  \n\"<api-name>\"\n:\n \n{\n\n\n    \n\"events\"\n:\n \n{\n\n      \n\"<event-name>\"\n:\n \n{\n\n        \n\"parameters\"\n:\n  \n{\n \n/*\n \njson\n \nschema\n \n*/\n \n}\n\n      \n}\n\n      \n//\n \nadditional\n \nevents\n\n    \n},\n\n\n    \n\"rpcs\"\n:\n \n{\n\n      \n\"<rpc-name>\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n \n/*\n \njson\n \nschema\n \n*/\n \n},\n\n        \n\"response\"\n:\n \n{\n \n/*\n \njson\n \nschema\n \n*/\n \n}\n\n      \n}\n\n      \n//\n \nadditional\n \nprocedures\n\n    \n}\n\n\n  \n}\n\n  \n//\n \nadditional\n \nAPIs\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nLightbus will likely upgrade to a newer JSON Schema version once the \njsonschema Python library\n has the \nrequisite support\n.",
            "title": "Schema"
        },
        {
            "location": "/schema/#specifying-types",
            "text": "Lightbus will create a schema by inspecting the parameters\nand  type hints  of your APIs' events and procedures.  You can use the schema functionality without type hints, but the level of validation\nprovided will be limited to ensuring parameter names match what is expected.  Take the following API as an example:  from   lightbus   import   Api ,   Event ,   Parameter  class   AuthApi ( Api ): \n     # Here we specify event parameters in the long-form using Parameter(). \n     # This provides sufficient information for the schema to be generated \n     user_registered   =   Event ( parameters = ( \n         Parameter ( 'username' ,   str ), \n         Parameter ( 'email' ,   str ), \n         Parameter ( 'is_admin' ,   bool ,   default = False ), \n     )) \n\n     class   Meta : \n         name   =   'auth' \n\n     # We annotate check_password() with the apropriate types \n     def   check_password ( self ,   username :   str ,   password :   str )   ->   bool : \n         return   username   ==   'admin'   and   password   ==   'secret'   Create this in a  bus.py  and run:  $ lightbus dumpschema  This will dump out the auto-generated schema for the above API. See schema format  (below) for example output.",
            "title": "Specifying types"
        },
        {
            "location": "/schema/#supported-data-types",
            "text": "Lightbus maps Python types to JSON types. While Python-specific values can be sent using Lightbus,\nthese values will arrive in their JSON form. For example, if you send a  string  then a  string  will arrive.\nHowever, if you send the  Decimal  value  3.124 , then you will receive the  string  value  3.124  instead.  The following types are reasonably interoperable:     Python type sent  JSON schema interpretation  Type received      str  string  str    int ,  float  number  int ,  float    bool  boolean  bool    list ,  tuple  array  list    None  null  None    dict ,  Mapping , etc  object  dict    Mapping[str, ...]  object , with  pattern properties  set  dict    Tuple[A, B, C]  array  with  maxItems/minItems  and  items  set.  list     The following types will be successfully encoded and sent, but will arrive as their encoded equivalent:     Python type  JSON Schema type  Value arrives as      bytes ,  Decimal ,  complex  string  str    datetime ,  date  str  str  (ISO 8601)    NamedTuple  with annotations  object  with  specific typed properties  dict    object  with annotations  object  with  specific typed properties  dict     Lightbus can also handle the following:     Python type  JSON Schema type      Any  {}  (any value)    Union[...]  oneOf{...}  (see  oneOf )    Enum  Sets  enum  property",
            "title": "Supported data types"
        },
        {
            "location": "/schema/#automatic-validation",
            "text": "By default this validation will be validated in both the\nincoming and outgoing directions. Outgoing refers to\nthe dispatching of events or procedure calls to the bus.\nIncoming refers to the processing of procedure calls or\nhandling of received events.  You can configuring this using the  validate  configuration  option.",
            "title": "Automatic validation"
        },
        {
            "location": "/schema/#validation-configuration",
            "text": "You can configure the validation behaviour in your\nbus'  config.yaml .",
            "title": "Validation configuration"
        },
        {
            "location": "/schema/#validate-bool-true",
            "text": "You can enable/disable validation using a boolean true/false flag:  # In config.yaml  apis: \n     default: \n         validate:  false   For finer grained control you can specify individual flags for incoming/outgoing\nvalidation:  # In config.yaml  apis: \n     default: \n         validate: \n           outgoing:  true \n           incoming:  false",
            "title": "validate (bool) = true"
        },
        {
            "location": "/schema/#strict_validation-bool-false",
            "text": "If  strict_validation  is  true  then calling a procedure for which no schema exists will\nresult in an error:  # In config.yaml  apis: \n     default: \n         strict_validation:  true",
            "title": "strict_validation (bool) = false"
        },
        {
            "location": "/schema/#manual-validation",
            "text": "TODO",
            "title": "Manual validation"
        },
        {
            "location": "/schema/#complex-types",
            "text": "The Lightbus can derive a schema from both named tuples and classes.",
            "title": "Complex types"
        },
        {
            "location": "/schema/#named-tuples",
            "text": "Take the following  User  named tuple:  # bus.py  from   lightbus   import   Api  from   typing   import   NamedTuple  class   User ( NamedTuple ): \n     username :   str \n     name :   str \n     email :   str \n     is_admin :   bool   =   False  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   get_user ( self ,   username :   str )   ->   User : \n         return   ...   Running  lightbus dumpschema  will produce the following:  { \n   \"auth\" :   { \n     \"events\" :   {}, \n     \"rpcs\" :   { \n       \"get_user\" :   { \n         \"parameters\" :   { \n           //   A   single   required   username   string   parameter \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"RPC auth.get_user() parameters\" , \n           \"type\" :   \"object\" \n           \"additionalProperties\" :   false , \n           \"properties\" :   { \n             \"username\" :   { \"type\" :   \"string\" } \n           }, \n           \"required\" :   [ \n             \"username\" \n           ], \n         }, \n\n         //   A   complex   object   is   returned \n         \"response\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"RPC auth.get_user() response\" , \n           \"type\" :   \"object\" , \n           \"properties\" :   { \n             \"username\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"name\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"email\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"is_admin\" :   { \n               \"default\" :   false , \n               \"type\" :   \"boolean\" \n             } \n           }, \n           \"required\" :   [ \"username\" ,   \"name\" ,   \"email\" ], \n           \"additionalProperties\" :   false \n         } \n       } \n     } \n   }  }",
            "title": "Named Tuples"
        },
        {
            "location": "/schema/#dataclasses",
            "text": "Dataclasses \nwere introduced in Python 3.7, with a backport available  for\nPython 3.6.  Lightbus supports dataclasses in the same way as it supports named tuples . For example:  # bus.py  from   lightbus   import   Api  from   dataclasses   import   dataclass  @dataclass ()  class   User ( object ): \n     username :   str \n     name :   str \n     email :   str \n     is_admin :   bool   =   False  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   get_user ( self ,   username :   str )   ->   User : \n         return   ...",
            "title": "Dataclasses"
        },
        {
            "location": "/schema/#classes",
            "text": "The same can be achieved using regular classes. However, there are some notable points:   Attributes prefixed with an underscore will be ignored  If used as a type hint for a parameter, then the class .... wait, will a json object get deserialised into a python object?\n   NO, this only happens in the config. I think you'll just get a dict for a parameter value\nTODO   from   lightbus   import   Api  class   User ( object ) : \n     username:  str \n     name:  str \n     email:  str \n     is_admin: bool =  False \n     # private attributes are ignored \n     _internal_value: str =  '' \n\n     def   do_something ( self ) : \n         pass  class   AuthApi ( Api ) : \n\n     class   Meta: \n         name =  'auth' \n\n     def   get_user (self, username: str) ->   User: \n         return   ...",
            "title": "Classes"
        },
        {
            "location": "/schema/#schema-format",
            "text": "You won't need to worry about the schema format in your day-to-day use\nof Lightbus. However, an understanding of the format will be very\nuseful if you decide to build additional tooling.  The Lightbus schema format is simply a collection of child JSON Schemas.\nBelow is the schema for the example  auth  API shown above:  //   Auto-generated   schema   for   auth   API  { \n   \"auth\" :   { \n\n     //   Events   specify   only   parameters \n     \"events\" :   { \n       \"user_registered\" :   { \n         \"parameters\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"Event auth.user_registered parameters\" , \n           \"type\" :   \"object\" , \n             \"username\" :   { \n               \"type\" :   \"string\" \n             }, \n           \"properties\" :   { \n             \"email\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"is_admin\" :   { \n               \"default\" :   false , \n               \"type\" :   \"boolean\" \n             } \n           }, \n           \"required\" :   [ \n             \"username\" , \n             \"email\" \n           ], \n           \"additionalProperties\" :   false \n         } \n       } \n     }, \n\n     //   RPCs   specify   both   parameters   and   response \n     \"rpcs\" :   { \n       \"check_password\" :   { \n         \"parameters\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"RPC auth.check_password() parameters\" , \n           \"type\" :   \"object\" , \n           \"properties\" :   { \n             \"username\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"password\" :   { \n               \"type\" :   \"string\" \n             } \n           }, \n           \"required\" :   [ \n             \"username\" , \n             \"password\" \n           ], \n           \"additionalProperties\" :   false \n         }, \n\n         \"response\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"RPC auth.check_password() response\" , \n           \"type\" :   \"boolean\" \n         } \n       } \n     } \n   }  }   The generalised format is as follows:  //   Generalised   Lightbus   schema   format  { \n   \"<api-name>\" :   { \n\n     \"events\" :   { \n       \"<event-name>\" :   { \n         \"parameters\" :    {   /*   json   schema   */   } \n       } \n       //   additional   events \n     }, \n\n     \"rpcs\" :   { \n       \"<rpc-name>\" :   { \n         \"parameters\" :   {   /*   json   schema   */   }, \n         \"response\" :   {   /*   json   schema   */   } \n       } \n       //   additional   procedures \n     } \n\n   } \n   //   additional   APIs  }    Note  Lightbus will likely upgrade to a newer JSON Schema version once the  jsonschema Python library  has the  requisite support .",
            "title": "Schema format"
        },
        {
            "location": "/transports/",
            "text": "TBA",
            "title": "Transports"
        },
        {
            "location": "/command-line-use/",
            "text": "TBA",
            "title": "Command line use"
        },
        {
            "location": "/debugging/",
            "text": "TBA",
            "title": "Debugging"
        },
        {
            "location": "/plugins/",
            "text": "TBA",
            "title": "Plugins"
        },
        {
            "location": "/contributing/",
            "text": "TBA. Contributions welcome!",
            "title": "Contributing"
        }
    ]
}